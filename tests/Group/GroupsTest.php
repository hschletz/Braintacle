<?php

namespace Braintacle\Test\Group;

use Braintacle\Database\Migration;
use Braintacle\Database\Migrations;
use Braintacle\Database\Table;
use Braintacle\Direction;
use Braintacle\Group\CacheExpirationTransformer;
use Braintacle\Group\Group;
use Braintacle\Group\Groups;
use Braintacle\Group\Members\ExcludedClient;
use Braintacle\Group\Members\ExcludedColumn;
use Braintacle\Group\Members\MembersColumn;
use Braintacle\Group\Membership;
use Braintacle\Group\Overview\OverviewColumn;
use Braintacle\KeyMapper\CamelCaseToSnakeCase;
use Braintacle\Locks;
use Braintacle\Search\Search;
use Braintacle\Search\SearchParams;
use Braintacle\Test\DatabaseConnection;
use Braintacle\Test\DataProcessorTestTrait;
use Braintacle\Transformer\DateTime;
use Braintacle\Transformer\DateTimeTransformer;
use DateTimeImmutable;
use DateTimeInterface;
use Doctrine\DBAL\Connection;
use Exception;
use Formotron\DataProcessor;
use Laminas\Db\Sql\Select;
use Laminas\Db\Sql\Sql;
use LogicException;
use Mockery;
use Mockery\Adapter\Phpunit\MockeryPHPUnitIntegration;
use Mockery\Mock;
use Model\Client\Client;
use Model\Config;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\UsesClass;
use PHPUnit\Framework\MockObject\MockObject;
use PHPUnit\Framework\TestCase;
use Psr\Clock\ClockInterface;
use Random\Engine\Xoshiro256StarStar;
use RuntimeException;
use Traversable;

#[CoversClass(Groups::class)]
#[UsesClass(Migration::class)]
#[UsesClass(Migrations::class)]
#[UsesClass(CamelCaseToSnakeCase::class)]
#[UsesClass(DateTime::class)]
final class GroupsTest extends TestCase
{
    use DataProcessorTestTrait;
    use MockeryPHPUnitIntegration;

    // Fuzz is generated by Randomizer. Test setup initializes it with a fixed
    // seed engine, resulting in reproducible values. Implementation details
    // might change with other PHP versions, resulting in a different value.
    // This value was generated with PHP 8.4.13.
    private const Fuzz = 26;
    private const InitialGroups = [
        [10, 'query_10', 0, 0],
        [11, 'query_11', 0, 0],
    ];
    private const UpdatedGroups = [
        [10, 'query_10', 1437675600, 1437675600 + self::Fuzz],
        [11, 'query_11', 0, 0],
    ];
    private const InitialMemberships = [
        [1, 10, 0],
        [2, 10, 1],
        [3, 10, 2],
        [4, 10, 0],
        [1, 11, 0],
    ];
    private const UpdatedMemberships = [
        [2, 10, 1],
        [3, 10, 2],
        [4, 10, 0],
        [5, 10, 0],
        [1, 11, 0],
    ];

    private function createGroups(
        ?ClockInterface $clock = null,
        ?Config $config = null,
        ?Connection $connection = null,
        ?DataProcessor $dataProcessor = null,
        ?Locks $locks = null,
        ?Search $search = null,
        ?Sql $sql = null,
    ): Groups {
        return new Groups(
            $clock ?? $this->createStub(ClockInterface::class),
            $config ?? $this->createStub(Config::class),
            $connection ?? $this->createStub(Connection::class),
            $dataProcessor ?? $this->createStub(DataProcessor::class),
            $locks ?? $this->createStub(Locks::class),
            $search ?? $this->createStub(Search::class),
            $sql ?? $this->createStub(Sql::class),
            new Xoshiro256StarStar(hash('sha256', 'Testing seed', true)),
        );
    }

    private function createGroupsMock(
        array $methods,
        ?ClockInterface $clock = null,
        ?Config $config = null,
        ?Connection $connection = null,
        ?DataProcessor $dataProcessor = null,
        ?Locks $locks = null,
        ?Search $search = null,
        ?Sql $sql = null,
    ): MockObject | Groups {
        return $this->getMockBuilder(Groups::class)->onlyMethods($methods)->setConstructorArgs([
            $clock ?? $this->createStub(ClockInterface::class),
            $config ?? $this->createStub(Config::class),
            $connection ?? $this->createStub(Connection::class),
            $dataProcessor ?? $this->createStub(DataProcessor::class),
            $locks ?? $this->createStub(Locks::class),
            $search ?? $this->createStub(Search::class),
            $sql ?? $this->createStub(Sql::class),
            new Xoshiro256StarStar(hash('sha256', 'Testing seed', true)),
        ])->getMock();
    }

    public function testGetGroup()
    {
        DatabaseConnection::with(function (Connection $connection): void {
            DatabaseConnection::initializeTable(
                Table::GroupsMain,
                ['id', 'name', 'deviceid', 'description', 'lastdate'],
                [
                    [1, 'name1', '_SYSTEMGROUP_', 'description1', '2025-10-10 14:49:01'],
                    [2, 'name2', 'not a group', null, '2025-10-10 14:49:02'],
                    [3, 'name2', '_SYSTEMGROUP_', 'description2', '2025-10-10 14:49:02'],
                ],
            );
            DatabaseConnection::initializeTable(
                Table::GroupInfo,
                ['hardware_id', 'create_time', 'revalidate_from', 'request'],
                [
                    [1, 1, 1, 'request1'],
                    [3, 3, 3, 'request2'],
                ]
            );

            $dateTimeTransformer = $this->createStub(DateTimeTransformer::class);
            $dateTimeTransformer->method('transform')->willReturn(new DateTimeImmutable());

            $dataProcessor = $this->createDataProcessor([
                CacheExpirationTransformer::class => $this->createStub(CacheExpirationTransformer::class),
                DateTimeTransformer::class => $dateTimeTransformer,
            ]);

            $groups = $this->createGroups(connection: $connection, dataProcessor: $dataProcessor);
            $group = $groups->getGroup('name2');

            $this->assertEquals(3, $group->id);
            $this->assertEquals('name2', $group->name);
            $this->assertEquals('request2', $group->dynamicMembersSql);
        });
    }

    public function testGetGroupNonExistentGroup()
    {
        DatabaseConnection::with(function (Connection $connection): void {
            DatabaseConnection::initializeTable(
                Table::GroupsMain,
                ['id', 'name', 'deviceid', 'description', 'lastdate'],
                [
                    [1, 'name', 'not a group', null, '2025-10-10 14:49:02'],
                ],
            );
            DatabaseConnection::initializeTable(Table::GroupInfo, [], []);

            $this->expectException(RuntimeException::class);
            $this->expectExceptionMessage('Unknown group name: name');

            $groups = $this->createGroups(connection: $connection);
            $groups->getGroup('name');
        });
    }

    public static function getGroupsProvider()
    {
        return [
            [OverviewColumn::Name, Direction::Ascending, ['name1', 'name2']],
            [OverviewColumn::Name, Direction::Descending, ['name2', 'name1']],
        ];
    }

    #[DataProvider('getGroupsProvider')]
    public function testGetGroups(OverviewColumn $order, Direction $direction, array $expected)
    {
        DatabaseConnection::with(function (Connection $connection) use ($order, $direction, $expected) {
            DatabaseConnection::initializeTable(
                Table::GroupsMain,
                ['id', 'name', 'description', 'deviceid', 'lastdate'],
                [
                    [1, 'name1', 'description1', '__SYSTEMGROUP__', '2015-02-02 19:01:00'],
                    [2, 'name2', 'description2', '__SYSTEMGROUP__', '2015-02-02 19:02:00'],
                ]
            );
            DatabaseConnection::initializeTable(
                Table::GroupInfo,
                ['hardware_id', 'request', 'create_time', 'revalidate_from'],
                [
                    [1, 'request1', 0, 0],
                    [2, 'request2', 0, 0],
                ]
            );

            $dateTimeTransformer = $this->createStub(DateTimeTransformer::class);
            $dateTimeTransformer->method('transform')->willReturn(new DateTimeImmutable());

            $dataProcessor = $this->createDataProcessor([
                CacheExpirationTransformer::class => $this->createStub(CacheExpirationTransformer::class),
                DateTimeTransformer::class => $dateTimeTransformer,
            ]);

            $groups = $this->createGroups(connection: $connection, dataProcessor: $dataProcessor);

            $result = iterator_to_array($groups->getGroups($order, $direction));

            $this->assertCount(2, $result);
            $this->assertContainsOnlyInstancesOf(Group::class, $result);
            $this->assertEquals($expected[0], $result[0]->name);
            $this->assertEquals($expected[1], $result[1]->name);
        });
    }

    public static function getMembersProvider()
    {
        return [
            'group4' => [MembersColumn::Id, Direction::Ascending, 4, [[1, Membership::Automatic]]],
            'group5' => [MembersColumn::Id, Direction::Ascending, 5, [[2, Membership::Manual]]],
            'group6_asc' => [
                MembersColumn::Membership,
                Direction::Ascending,
                6,
                [
                    [2, Membership::Automatic],
                    [1, Membership::Manual],
                ],
            ],
            'group6_desc' => [
                MembersColumn::Membership,
                Direction::Descending,
                6,
                [
                    [1, Membership::Manual],
                    [2, Membership::Automatic],
                ],
            ],
        ];
    }

    #[DataProvider('getMembersProvider')]
    public function testGetMembers(MembersColumn $order, Direction $direction, int $groupId, array $expected)
    {
        DatabaseConnection::with(function (Connection $connection) use ($order, $direction, $groupId, $expected): void {
            DatabaseConnection::initializeTable(
                Table::GroupsMain,
                ['id', 'deviceid', 'name', 'userid', 'lastdate'],
                [
                    [1, 'id1', 'name1', 'user1', '2025-03-15T17:11:14'],
                    [2, 'id2', 'name2', 'user2', '2015-08-11T14:18:50'],
                    [3, 'id3', 'name3', 'user3', '2025-03-15T17:11:14'],
                    [4, '_SYSTEMGROUP_', 'group1', null, '2025-03-15T17:11:14'],
                    [5, '_SYSTEMGROUP_', 'group2', null, '2025-03-15T17:11:14'],
                    [6, '_SYSTEMGROUP_', 'group3', null, '2025-03-15T17:11:14'],
                ],
            );
            DatabaseConnection::initializeTable(Table::GroupMemberships, ['hardware_id', 'group_id', 'static'], [
                [1, 4, 0],
                [1, 5, 2],
                [2, 4, 2],
                [2, 5, 1],
                [1, 6, 1],
                [2, 6, 0],
            ]);

            $dateTimeTransformer = $this->createStub(DateTimeTransformer::class);
            $dateTimeTransformer->method('transform')->willReturn(new DateTimeImmutable());

            $dataProcessor = $this->createDataProcessor([DateTimeTransformer::class => $dateTimeTransformer]);

            $group = new Group();
            $group->id = $groupId;

            $groups = $this->createGroupsMock(
                ['updateMemberships'],
                connection: $connection,
                dataProcessor: $dataProcessor,
            );
            $groups->expects($this->once())->method('updateMemberships')->with($group, false);

            $members = $groups->getMembers($group, $order, $direction);
            $this->assertEquals(
                $expected,
                array_map(
                    fn($member) => [$member->id, $member->membership],
                    [...$members],
                ),
            );
        });
    }

    public function testGetExcludedClients()
    {
        DatabaseConnection::with(function (Connection $connection): void {
            $groupId = 4;
            $order = ExcludedColumn::Id;
            $direction = Direction::Ascending;
            $inventoryDate = '2025-03-15T12:11:14';
            $expectedInventoryDate = new DateTimeImmutable($inventoryDate);

            DatabaseConnection::initializeTable(
                Table::GroupsMain,
                ['id', 'deviceid', 'name', 'userid', 'lastdate'],
                [
                    [1, 'id1', 'name1', 'user1', '2025-03-15T17:11:14'],
                    [2, 'id2', 'name2', 'user2', $inventoryDate],
                    [3, 'id3', 'name3', 'user3', '2025-03-15T17:11:14'],
                    [4, '_SYSTEMGROUP_', 'group1', null, '2025-03-15T17:11:14'],
                    [5, '_SYSTEMGROUP_', 'group2', null, '2025-03-15T17:11:14'],
                    [6, '_SYSTEMGROUP_', 'group3', null, '2025-03-15T17:11:14'],
                ],
            );
            DatabaseConnection::initializeTable(Table::GroupMemberships, ['hardware_id', 'group_id', 'static'], [
                [1, 4, 0],
                [1, 5, 2],
                [2, 4, 2],
                [2, 5, 1],
                [1, 6, 1],
                [2, 6, 0],
            ]);

            $dateTimeTransformer = $this->createMock(DateTimeTransformer::class);
            $dateTimeTransformer
                ->method('transform')
                ->with(
                    $this->callback(
                        // Compare objects instead of strings to acommodate for
                        // different timestamp formats (Some databases use 'T'
                        // as separator, others use ' ')
                        fn(string $timestamp) => new DateTimeImmutable($timestamp) == $expectedInventoryDate
                    )
                )
                ->willReturn($expectedInventoryDate);

            $dataProcessor = $this->createDataProcessor([DateTimeTransformer::class => $dateTimeTransformer]);

            $group = new Group();
            $group->id = $groupId;

            $groups = $this->createGroupsMock(
                ['updateMemberships'],
                connection: $connection,
                dataProcessor: $dataProcessor,
            );
            $groups->expects($this->once())->method('updateMemberships')->with($group, false);

            /** @var Traversable */
            $result = $groups->getExcludedClients($group, $order, $direction);
            /** @var ExcludedClient[] */
            $result = iterator_to_array($result);
            $this->assertCount(1, $result);

            $client = $result[0];
            $this->assertEquals(2, $client->id);
            $this->assertEquals('name2', $client->name);
            $this->assertEquals('user2', $client->userName);
            $this->assertEquals($expectedInventoryDate, $client->inventoryDate);
        });
    }

    public function testSetSearchResultsQuery()
    {
        $group = $this->createStub(Group::class);
        $searchParams = $this->createStub(SearchParams::class);
        $select = $this->createStub(Select::class);

        $search = $this->createMock(Search::class);
        $search->expects($this->once())->method('getQuery')->with($searchParams)->willReturn($select);
        $search->expects($this->never())->method('getClients');

        $groups = $this->createGroupsMock(['setQuery', 'setMembers'], search: $search);
        $groups->expects($this->once())->method('setQuery')->with($group, $select);
        $groups->expects($this->never())->method('setMembers');

        $groups->setSearchResults($group, $searchParams, Membership::Automatic);
    }

    public static function setSearchResultsClientsProvider()
    {
        return [
            [Membership::Manual],
            [Membership::Never],
        ];
    }

    #[DataProvider('setSearchResultsClientsProvider')]
    public function testSetSearchResultsClients(Membership $membershipType)
    {
        $group = $this->createStub(Group::class);
        $searchParams = $this->createStub(SearchParams::class);
        $clients = [$this->createStub(Client::class)];

        $search = $this->createMock(Search::class);
        $search->expects($this->never())->method('getQuery');
        $search->expects($this->once())->method('getClients')->with($searchParams)->willReturn($clients);

        $groups = $this->createGroupsMock(['setQuery', 'setMembers'], search: $search);
        $groups->expects($this->never())->method('setQuery');
        $groups->expects($this->once())->method('setMembers')->with($group, $clients, $membershipType);

        $groups->setSearchResults($group, $searchParams, $membershipType);
    }

    public static function setQueryProvider()
    {
        return [
            [[]],
            [[['columns' => []]]],
        ];
    }

    #[DataProvider('setQueryProvider')]
    public function testSetQuery(array $joins)
    {
        DatabaseConnection::with(function (Connection $connection) use ($joins): void {
            DatabaseConnection::initializeTable(Table::GroupInfo, ['hardware_id', 'request'], [
                [10, 'query_10'],
                [11, 'query_11'],
            ]);

            $query = 'query_new';

            $select = $this->createMock(Select::class);
            $select->method('getRawState')->willReturnMap([
                [Select::COLUMNS, ['id']],
                [Select::JOINS, $joins],
            ]);

            $sql = $this->createMock(Sql::class);
            $sql->method('buildSqlString')->with($select)->willReturn($query);

            $group = new Group();
            $group->id = 10;

            $groups = $this->createGroupsMock(['updateMemberships'], connection: $connection, sql: $sql);
            $groups->expects($this->once())->method('updateMemberships')->with(
                $this->callback(fn(Group $group) => $group->dynamicMembersSql == $query),
                true,
            );
            $groups->setQuery($group, $select);

            $content = $connection
                ->createQueryBuilder()
                ->select('request')
                ->from(Table::GroupInfo)
                ->orderBy('hardware_id')
                ->fetchFirstColumn();
            $this->assertEquals([$query, 'query_11'], $content);
        });
    }

    public function testSetQueryInvalidQuery()
    {
        $this->expectException(LogicException::class);
        $this->expectExceptionMessage('Expected 1 column, got 2');

        $connection = $this->createMock(Connection::class);
        $connection->expects($this->never())->method('update');

        $group = $this->createMock(Group::class);

        $joins = [
            ['columns' => []],
            ['columns' => ['name']],
        ];
        $select = $this->createStub(Select::class);
        $select->method('getRawState')->willReturnMap([
            [Select::COLUMNS, ['id']],
            [Select::JOINS, $joins],
        ]);

        $groups = $this->createGroupsMock(['updateMemberships'], connection: $connection);
        $groups->expects($this->never())->method('updateMemberships');
        $groups->setQuery($group, $select);
    }

    public static function setMembersProvider()
    {
        return [
            [Membership::Manual, [
                [1, 10, 1],
                [2, 10, 1],
                [3, 10, 1],
                [4, 10, 0],
                [5, 10, 1],
                [1, 11, 0],
            ]],
            [Membership::Never, [
                [1, 10, 2],
                [2, 10, 2],
                [3, 10, 2],
                [4, 10, 0],
                [5, 10, 2],
                [1, 11, 0],
            ]],
        ];
    }

    #[DataProvider('setMembersProvider')]
    public function testSetMembers(Membership $type, array $expected)
    {
        DatabaseConnection::with(function (Connection $connection) use ($type, $expected) {
            DatabaseConnection::initializeTable(Table::GroupMemberships, ['hardware_id', 'group_id', 'static'], [
                [1, 10, 0],
                [2, 10, 1],
                [3, 10, 2],
                [4, 10, 0],
                [1, 11, 0],
            ]);

            $client1 = $this->createStub(Client::class);
            $client1->id = 1;

            $client2 = $this->createStub(Client::class);
            $client2->id = 2;

            $client3 = $this->createStub(Client::class);
            $client3->id = 3;

            $client5 = $this->createStub(Client::class);
            $client5->id = 5;

            $clients = [$client1, $client2, $client3, $client5];

            $group = new Group();
            $group->id = 10;

            $locks = $this->createMock(Locks::class);
            $locks->expects($this->once())->method('lock')->with($group)->willReturn(true);
            $locks->expects($this->once())->method('release');

            $groups = $this->createGroups(connection: $connection, locks: $locks);
            $groups->setMembers($group, $clients, $type);

            $content = $connection
                ->createQueryBuilder()
                ->select('hardware_id', 'group_id', 'static')
                ->from(Table::GroupMemberships)
                ->addOrderBy('group_id')
                ->addOrderBy('hardware_id')
                ->fetchAllNumeric();
            $this->assertEquals($expected, $content);
        });
    }

    public function testSetMembersLockingFailure()
    {
        DatabaseConnection::with(function (Connection $connection): void {
            DatabaseConnection::initializeTable(Table::GroupMemberships, ['hardware_id', 'group_id', 'static'], [
                [1, 10, 0],
            ]);

            $group = $this->createStub(Group::class);

            $locks = $this->createMock(Locks::class);
            $locks->expects($this->once())->method('lock')->with($group)->willReturn(false);
            $locks->expects($this->never())->method('release');

            $client = $this->createStub(Client::class);
            $client->id = 1;

            $groups = $this->createGroups(connection: $connection, locks: $locks);
            $groups->setMembers($group, [$client], Membership::Manual);

            $content = $connection
                ->createQueryBuilder()
                ->select('hardware_id', 'group_id', 'static')
                ->from(Table::GroupMemberships)
                ->addOrderBy('group_id')
                ->addOrderBy('hardware_id')
                ->fetchAllNumeric();
            $this->assertEquals([[1, 10, 0]], $content);
        });
    }

    public function testSetMembersExceptionInTransaction()
    {
        $this->expectExceptionMessage('test');

        DatabaseConnection::with(function (): void {
            // Flush table to guarantee that inseert() will be called instead of update()
            DatabaseConnection::initializeTable(Table::GroupMemberships, [], []);

            $connection = $this->createMock(Connection::class);
            $connection->method('createQueryBuilder')->willReturn($connection->createQueryBuilder());
            $connection->expects($this->once())->method('beginTransaction');
            $connection->expects($this->once())->method('rollBack');
            $connection->expects($this->never())->method('commit');
            $connection->method('insert')->willThrowException(new Exception('test'));

            $locks = $this->createMock(Locks::class);
            $locks->expects($this->once())->method('lock')->willReturn(true);
            $locks->expects($this->once())->method('release');

            $group = new Group();
            $group->id = 10;

            $client = $this->createStub(Client::class);
            $client->id = 1;

            $groups = $this->createGroups(connection: $connection, locks: $locks);
            $groups->setMembers($group, [$client], Membership::Manual);
        });
    }

    public static function updateMembershipsProvider()
    {
        return [
            'force update, but no query' => [true, false, null, true, false],
            'force update, but locking fails' => [true, true, null, false, false],
            'not expired yet' => [false, true, new DateTimeImmutable('2015-07-23 20:21:00'), true, false],
            'not expired, but forced' => [true, true, new DateTimeImmutable('2015-07-23 20:21:00'), true, true],
            'expired' => [false, true, new DateTimeImmutable('2015-07-23 20:19:00'), true, true],
            'no cache yet' => [false, true, null, true, true],
        ];
    }

    #[DataProvider('updateMembershipsProvider')]
    public function testUpdateMemberships(
        bool $force,
        bool $setSql,
        ?DateTimeInterface $expires,
        bool $lockSuccess,
        bool $updateExpected,
    ) {
        DatabaseConnection::with(function (Connection $connection) use (
            $force,
            $setSql,
            $expires,
            $lockSuccess,
            $updateExpected,
        ) {
            DatabaseConnection::initializeTable(Table::ClientTable, ['id', 'name', 'deviceid'], [
                [1, 'client_1', 'client_1'],
                [2, 'client_2', 'client_2'],
                [3, 'client_3', 'client_3'],
                [4, 'client_4', 'client_4'],
                [5, 'client_5', 'client_5'],
            ]);
            DatabaseConnection::initializeTable(
                Table::GroupInfo,
                ['hardware_id', 'request', 'create_time', 'revalidate_from'],
                self::InitialGroups,
            );
            DatabaseConnection::initializeTable(
                Table::GroupMemberships,
                ['hardware_id', 'group_id', 'static'],
                self::InitialMemberships,
            );

            $now = new DateTimeImmutable('2015-07-23 20:20:00');

            $clock = $this->createStub(ClockInterface::class);
            $clock->method('now')->willReturn($now);

            $config = $this->createStub(Config::class);
            $config->method('__get')->willReturnMap([
                ['groupCacheExpirationInterval', 600],
                ['groupCacheExpirationFuzz', 60],
            ]);

            $group = new Group();
            $group->id = 10;
            $group->dynamicMembersSql = $setSql ? 'SELECT id FROM hardware WHERE id IN(2,3,4,5)' : null;
            $group->cacheCreationDate = null;
            $group->cacheExpirationDate = $expires;

            $locks = $this->createMock(Locks::class);
            $locks->method('lock')->with($group)->willReturn($lockSuccess);
            if ($updateExpected) {
                $locks->expects($this->once())->method('release');
            }

            $groups = $this->createGroups(clock: $clock, config: $config, connection: $connection, locks: $locks);
            $groups->updateMemberships($group, $force);

            // Group object is only updated when there was data to update.
            $this->assertSame(
                $updateExpected ? $now : null,
                $group->cacheCreationDate,
            );
            $this->assertEquals(
                $updateExpected ? new DateTimeImmutable('2015-07-23 20:30:26') : $expires,
                $group->cacheExpirationDate
            );

            $groups = $connection->fetchAllNumeric(
                'SELECT hardware_id, request, create_time, revalidate_from FROM groups ORDER BY hardware_id'
            );
            $this->assertEquals($updateExpected ? self::UpdatedGroups : self::InitialGroups, $groups);

            $memberships = $connection->fetchAllNumeric(
                'SELECT hardware_id, group_id, static FROM groups_cache ORDER BY group_id, hardware_id'
            );
            $this->assertEquals($updateExpected ? self::UpdatedMemberships : self::InitialMemberships, $memberships);
        });
    }

    public function testUpdateCache()
    {
        DatabaseConnection::with(function (Connection $connection) {
            DatabaseConnection::initializeTable(Table::GroupsMain, ['id', 'deviceid', 'name', 'lastdate'], [
                [1, '_SYSTEMGROUP_', 'name1', '2015-02-02 19:01:00'],
                [2, '_SYSTEMGROUP_', 'name2', '2015-02-02 19:02:00'],
                [3, '_SYSTEMGROUP_', 'name3', '2015-02-02 19:03:00'],
            ]);
            DatabaseConnection::initializeTable(
                Table::GroupInfo,
                ['hardware_id', 'request', 'create_time', 'revalidate_from'],
                [
                    [1, null, 0, 75],
                    [2, null, 0, 95],
                    [3, null, 0, 85],
                ]
            );

            $clock = $this->createStub(ClockInterface::class);
            $clock->method('now')->willReturn(new DateTimeImmutable('@100'));

            $config = $this->createMock(Config::class);
            $config->method('__get')->with('groupCacheExpirationInterval')->willReturn(10);

            $dateTimeTransformer = $this->createStub(DateTimeTransformer::class);
            $dateTimeTransformer->method('transform')->willReturn(new DateTimeImmutable());

            $dataProcessor = $this->createDataProcessor([
                CacheExpirationTransformer::class => $this->createStub(CacheExpirationTransformer::class),
                DateTimeTransformer::class => $dateTimeTransformer,
            ]);

            /**
             * @var Mock | Groups
             * @psalm-suppress InvalidArgument (Mockery bug)
             */
            $groups = Mockery::mock(Groups::class, [
                $clock,
                $config,
                $connection,
                $dataProcessor,
                $this->createStub(Locks::class),
                $this->createStub(Search::class),
                $this->createStub(Sql::class),
            ])->makePartial();
            $groups
                ->shouldReceive('updateMemberships')
                ->once()
                ->withArgs(fn(Group $group, bool $force) => $group->id == 1 && $force);
            $groups
                ->shouldReceive('updateMemberships')
                ->once()
                ->withArgs(fn(Group $group, bool $force) => $group->id == 3 && $force);

            $groups->updateCache();
        });
    }
}
